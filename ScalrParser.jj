PARSER_BEGIN(ScalrParser)
import java.io.*;

public class ScalrParser {
    public static void main(String[] args) {
    	FileReader fis;
		BufferedReader br;
		String line;
        try {
			br = new BufferedReader(new FileReader(args[0]));
            String text = "";
            while ((line = br.readLine()) != null) {
                text += line + "\n";
            }
            new ScalrParser(new java.io.StringReader(text)).S();
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}
PARSER_END(ScalrParser)

SKIP : { " " | "\t" }
TOKEN: {
    "==" | ">" | "<" | "<=" | ">=" |
    "and" | "or" | "not" | "->" | "." | "\n" |
    "" | "," | "+" | "-" | "%" | "(" | ")" | "[" | "]" |
	"note" | "pitch" | "volume" | 
       	"duration" | "end" | "func" |
	"while" | "foreach" | "in" |
	"if" | "else" | "track" |
	<LETTER: ["A"-"Z"] | ["a"-"z"]> |
	<INT: "0" | ["1"-"9"](["0"-"9"])+> |
	<ID: <LETTER>(<LETTER> | <INT>)*> |
    <DEGREE: ["A"-"G"]("b" | "s")?["0"-"10"]>
	}

void parameters(): {} {<ID> parameters1()}

void parameters1(): {} {"," parameters() 
| ""}

void block(): {} {block() "\n" line() 
| line()}

void line(): {} {loop() 
| conditional() 
| assignment() 
| "\n" 
| ""}

void loop(): {} {"while" "(" boolean-expr() ")" block() "end" 
| "foreach" "(" <ID> "in" return() ")" block() "end"}

void boolean-expr(): {} {boolean-expr() "and" b-e1() 
| boolean-expr() "or" b-e1() 
| b-e1()}

void b-e1(): {} {"not" boolean-expr() 
| operand() "==" operand() 
| operand() ">" operand() 
| operand() "<" operand() 
| operand() "<=" operand() 
| operand() ">=" operand()}

void conditional(): {} {"if" "(" boolean-expr() ")" block() "end" "\n" conditional1()}

void conditional1(): {} {"else" conditional() 
| "else" block() "end" 
| ""}

void assignment(): {} {<ID> "=" expression() 
| <ID> "+=" expression() 
| <ID> "*=" expression() 
| <ID> "/=" expression() 
| <ID> "%=" expression()}

void expression(): {} {expression() "+" expr1() 
| expression() "-" expr1() 
| expr1()}

void expr1(): {} {expr1() "*" expr2() 
| expr1() "/" expr2() 
| expr2()}

void expr2(): {} {expr2() "%" expr3() 
| expr3()}

void expr3(): {} {"(" expression() ")" 
| operand()} 

void operand(): {} {<ID> 
| <INT> 
| note() 
| sequence()}

void note(): {} {note() 
| note() "." "pitch" "(" expression() ")" 
| note() "." "pitch" "(" <DEGREE> ")" 
| note() "." "pitch" "(" "+" expression() ")" 
| note() "." "pitch" "(" "-" expression() ")" 
| note() "." "pitch" "(" expression() ")" 
| note() "." "volume" "(" expression() ")" 
| note() "." "volume" "(" "+" expression() ")" 
| note() "." "volume" "(" "-" expression() ")" 
| note() "." "duration" "(" expression() ")" 
| note() "." "duration" "(" "+" expression() ")" 
| note() "." "duration" "(" "-" expression() ")"}

void return(): {} {identifier() 
| sequence()}

void sequence(): {} {"[" note-list() "]"}

void note-list(): {} {note() note-list'()}

void note-list'(): {} {"," note-list() 
| ""}

void return(): {} {identifier() 
| sequence()}

void track(): {} {track() "->" return()}