options
{
  LOOKAHEAD=3;
  STATIC = false; 
}

PARSER_BEGIN(ScalrParser2)
package parser;
import java.io.*;
import scalr.variable.*;
import scalr.Exceptions.*;
import tuple.*;
import scalr.expression.*;
import java.util.ArrayList;
import java.util.Collections;

public class ScalrParser2 {
    public static void main(String[] args) throws TypeError {
		BufferedReader br = null;
        String text = "";
        try {
			br = new BufferedReader(new FileReader(args[0]));
            String line = "";
            while ((line = br.readLine()) != null) {
                text += line + "\n";

            }
        ScalrParser2 parser = new ScalrParser2(new java.io.StringReader(text));
        //SymbolTable.addFunc("test");
        //SymbolTable.currentFunctionScope = "test";

       parser.tscalr();
       // parser.function();
       //System.out.println(parser.funcall());
        //System.out.println(SymbolTable.reference);
	    System.out.println("grats, your program compiled alright");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed:");
            e.printStackTrace();
        }
    }
}
PARSER_END(ScalrParser2)

SKIP : { " " | "\t" | <"/*" (~[])* "*/"> | "\n"}
TOKEN: {
       "and" | "or" | "not" | "->" | "." |
        "," | "\"" | "+" | "-" | "%" | "(" | ")" | "[" | "]" |
	"note" | "pitch" | "volume" | 
       	"duration" | "quarter" | "half" | "whole" |
	"end" | "func" | "main" | "while" | "foreach" |
	 "in" |	"if" | "else" | "import" | "track" | ".fscalr" |
	<POST: "--" | "++"> |
	<LENGTH: "whole" | "half" | "quarter" | "eighth" | "sixteenth" | "thirtysec" | "quarterT" |
		"eighthT" | "sixteenthT" | "thirtysecT"> |
	<ASSIGN: "=" | "+=" | "-=" | "*=" | "/=" | "%="> |
	<RELN: "==" | "<" | ">" | ">=" "<="> |
	<INT: "0" | ["1"-"9"](["0"-"9"])*> |
	<ID: ["a"-"z"](["A"-"Z"] | ["a"-"z"] | <INT> | "_")*> |
    	<DEGREE: ["A"-"G"]("b" | "s")?(["0"-"9"] | "1""0")>
	}

/*********************************NEW SHIT STARTS*************************************/
void tscalr() throws Exception: { String out;} { imp1() mainFunc() out=track1()
{System.out.println(out);}
}

void imp() throws Exception: {} { 
"import" fscalrFile() {System.out.println("import statement matched");}
}

void imp1() throws Exception: {} { 
imp() imp1()
| {}
}



void fscalrFile() throws Exception: {
	String s;
	String fname;
	BufferedReader br2;
	String text2;
	String line2;
	ScalrParser2 parser2; 

} { s = id()

{
	fname = "tests/" + s + ".fscalr";

	System.out.println(fname);


	br2 = null;
        text2 = "";
        try {
			br2 = new BufferedReader(new FileReader(fname));
            line2 = "";
            while ((line2 = br2.readLine()) != null) {
                text2 += line2 + "\n";

            }

            System.out.println("*********");

            System.out.println(text2.trim());

            System.out.println("*********");

        parser2 = new ScalrParser2(new java.io.StringReader(text2.trim()));
        parser2.function();
		} catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }

}
}

void block() throws Exception: {System.out.println("matching block:");} { 
line1() "end" {System.out.println("block matched");}}
	

void mainFunc() throws Exception:{
	System.out.println("starting main def");
	String funcName = "main";
	Function f;
	ArrayList<Expression> expressions = new ArrayList<Expression>();
	Expression returnSeq;
} {
	"main" {SymbolTable.currentFunctionScope= funcName; f= new Function(funcName); } 
	//get all the statements using line
	 expressions = line1() {
		for(Expression e: expressions){
			//add the statements to the function object with the name main
			f.addStatement(e);
		}
	}
	
	"end" {
		f.getValue();
	}
}

/*****************************END OF NEW SHIT*********************************/

void idDefs(ArrayList<String> params): {
	Token t;
} {
	t = <ID> { params.add(t.image); }
}
void function() throws Exception: {
	System.out.println("starting function def");
	String funcName;
	Function f;
	ArrayList<String> params= new ArrayList<String>();
	ArrayList<Expression> expressions = new ArrayList<Expression>();
	Expression returnSeq;
} {
"func" funcName=id() {SymbolTable.currentFunctionScope= funcName; f= new Function(funcName); } 
	"(" (idDefs(params) ("," idDefs(params))*)? {
		for(String s: params){
			f.addParameter(s);
		}
	} 

	")" expressions = line1() {
	System.out.println("!!!!!!!!!!!!!!!!! exp size is "+ expressions.size());
		for(Expression e: expressions){
			System.out.println("!!!!!!!!!!!!!!adding statement");
			f.addStatement(e);
		}
	}
	
	returnSeq= sequence(){
		System.out.println("hit return sequence");
		f.addStatement(returnSeq);
	} 
	"end" {
		System.out.println("adding function with name "+ f.getName());
		SymbolTable.addFuncRef(f);
	}
}

String track() throws Exception: {String out;
				Expression e;}
{
	"track" "->" e=sequence() 
	{
		Sequence temp = (Sequence) e.getValue();
		out = temp.flattenedToString();
		return out;
	}
}

String track1() throws Exception: {String one; String out= "";} { 
one=track() out=track1() {out=one+out; return out;}
| {return out;}
}

Expression line() throws Exception: {
	Expression e;
	System.out.println("calling LINE");
} {
//loop() {System.out.println("loop line matched");}
//| conditional() {System.out.println("conditional line matched");}
//| 
	e= assignment() {
		System.out.println("end of assignment");
		return e;
	}
	
	//note() {
	//	System.out.println("line consisting of note");
	//	return null;
	//}
	//|
	

}


ArrayList<Expression> line1() throws Exception: {
	ArrayList<Expression> out; 
	Expression e;
} {
e=line() out=line1(){
	
	if(e != null){
		out.add(e);
		return out;
	}
	return out;
}
| {}{
	return new ArrayList<Expression>();
}
}

Expression assignment() throws Exception: {
	String t1;
	Expression t2;
	System.out.println("starting assignment");
	System.out.println(SymbolTable.reference);
} 
{
	
	t1= id() <ASSIGN> t2= funcall() {
									
									System.out.println("assignment of a funcall!!!");
									CreationOperator co = new CreationOperator(t1);
									co.addOperand(t2);
									co.addFunc(SymbolTable.currentFunctionScope);

									return co;
	}
	|
	t1=id() <ASSIGN> t2=sequence() {
									System.out.println("assignment case sequence");
									CreationOperator co = new CreationOperator(t1);
									co.addOperand(t2);
									co.addFunc(SymbolTable.currentFunctionScope);
									return co;}
	|
	t1=id() <ASSIGN> t2=note() { 	System.out.println("assignment case note");
									CreationOperator co = new CreationOperator(t1);
									co.addOperand(t2);
									co.addFunc(SymbolTable.currentFunctionScope);
									return co;
								}
	|

	t1=id() <ASSIGN> t2=expression(){
									System.out.println("assignment case expression");
									CreationOperator co = new CreationOperator(t1);
									co.addOperand(t2);
									co.addFunc(SymbolTable.currentFunctionScope);
									return co;
	}
}
String id() throws Exception:
{Token t;}
{
t=<ID> {return t.image;}  //blah should be changed with the string that shows in which function we ARE!!!
}

Expression expression() throws Exception: {
	Expression ex;
	Pair<String, Expression> t;
	System.out.println("called expression!");	
} 
{
ex=expr1() t=expr0()
{
	BinaryOperator out = new BinaryOperator(t.getValue0());
	out.addOperand(ex);
	out.addOperand(t.getValue1());
	return out;
}
|
ex= expr1()
{
	return ex;
}
}


Pair<String, Expression> expr0() throws Exception: {Expression e;} {
"+" e=expr1() { return Pair.with("+", e); }
| "-" e=expr1() { return Pair.with("-", e); }
}

Expression expr1() throws Exception: {
	Expression ex;
	Pair<String, Expression> t;
} { ex=expr3() t=expr2() 
{
	BinaryOperator out = new BinaryOperator(t.getValue0());
	out.addOperand(ex);
	out.addOperand(t.getValue1());
	return out;
}
|
ex= expr3()
{
	return ex;
}
}

Pair<String, Expression> expr2() throws Exception: {Expression e;} {
"*" e=expr3() { return Pair.with("*", e); }
| "/" e=expr3() { return Pair.with("/", e); }
}

Expression expr3() throws Exception: {
	Expression ex;
	Pair<String, Expression> t;
} {ex = expr5() t=expr4()
{
	BinaryOperator out = new BinaryOperator(t.getValue0());
	out.addOperand(ex);
	out.addOperand(t.getValue1());
	return out;
}
|
ex= expr5()
{
	return ex;
}
}

Pair<String, Expression> expr4() throws Exception: {
	Expression ex;
} {
	"%" ex = expr5() { return Pair.with("%", ex); }
}

Expression expr5() throws Exception: {
	Expression ex;
} {
"(" ex = expression() ")" {return ex;}
| ex = operand() {return ex;}
}

ScalrNum num() throws Exception:
{Token t;}
{
t=<INT> {return new ScalrNum(Integer.parseInt(t.image));}
}

Expression operand() throws Exception: {
	Expression ex;
	Token t;
	Sequence s;
} {
t=<ID> {VariableReference e = new VariableReference(t.image, SymbolTable.currentFunctionScope);
	return e;}
| 
s = funcall() {return s;}


| ex = note() 
{
	return ex;
}
| ex = sequence() {return ex;}
| ex=num() {return ex;}
}

Sequence funcall() throws Exception: {
	Sequence s;
	String t;
	ArrayList<Expression> ex;
	System.out.println("called funcall");
} { 
t = id() "(" ex = parameters() ")" 
{
	System.out.println("funcall case 1 ");
	
	Function f = SymbolTable.getFuncRef(t);
	System.out.println(SymbolTable.functionReferences);
	if(ex.isEmpty()){
		s = (Sequence) f.getValue();

	}
	else{
		Collections.reverse(ex);

		
		Expression[] temp = ex.toArray(new Expression[ex.size()]);
		s = (Sequence) f.getValue(temp);	
	}
	
	return s;
}
|
t = id() "()" 
{
	System.out.println("funcall case 2 ");
	Function f = SymbolTable.getFuncRef(t);
	System.out.println("funcall case 3 ");
	s = (Sequence) f.getValue();
	System.out.println("funcall case 4");
	return s;
}
}

ArrayList<Expression> parameters() throws Exception: {
	Expression ex;
	ArrayList<Expression> ex2;
	System.out.println("parameters called");
} { 
ex = operand() ex2 = parameters1() 
{
	ex2.add(ex);
}
|
ex= operand()
{
	ex2 = new ArrayList<Expression>();
	ex2.add(ex);
	return ex2;
}

}

ArrayList<Expression> parameters1() throws Exception: {
	ArrayList<Expression> out;
} { "," out = parameters() {return out;}}

Expression sequence() throws Exception: {
	Sequence s;
	Expression n;
	String id;
	System.out.println("called sequence");

} {
"[" "]"
{
	System.out.println("sequence case 1");
	s = new Sequence();
	return s;
}
| "[" n = note() s = sequence1() "]" 
{
	System.out.println("sequence case 2");
	s.addNoteToStart(n);
	return s;
}
| id = id() 
{
	System.out.println("sequence case 3");
	VariableReference e = new VariableReference(id, SymbolTable.currentFunctionScope);
	return e;
}
}

Sequence sequence1() throws Exception: {
	Sequence s;
	Expression n;

} {
"," n = note() s = sequence1()
{
	s.addNoteToStart(n);
	return s;
}
| {}
{
	System.out.println("created new sequence");
	s = new Sequence();
	return s;
}
}

Expression note() throws Exception: {
	Token t;
	Expression n = Note.note();
} {
	("break.half" {return Note.getBreak("half");})
	|("break.quarter" {return Note.getBreak("quarter");})
	|("break.whole" {return Note.getBreak("whole");})
	|("break.eighth" {return Note.getBreak("eighth");})
	|("break.sixteenth" {return Note.getBreak("sixteenth");})
	|("break.thirtysec" {return Note.getBreak("thirtysec");})
	|
	(("note" | t = <ID> { n = new VariableReference(t.image, SymbolTable.currentFunctionScope); }) 
	(".pitch(" n = pitch(n) ")" | ".length(" n = length(n) ")" | ".volume(" n = volume(n) ")" 
	| ".half" {NoteOps no = new NoteOps("len"); no.addOperand(n); no.addLength("half"); n=no;}
	| ".whole" {NoteOps no = new NoteOps("len"); no.addOperand(n); no.addLength("whole"); n=no;}
	| ".quarter" {NoteOps no = new NoteOps("len"); no.addOperand(n); no.addLength("quarter"); n=no;}
	| ".eighth" {NoteOps no = new NoteOps("len"); no.addOperand(n); no.addLength("eighth"); n=no;}
	| ".sixteenth" {NoteOps no = new NoteOps("len"); no.addOperand(n); no.addLength("sixteenth"); n=no;}
	| ".thirtysec" {NoteOps no = new NoteOps("len"); no.addOperand(n); no.addLength("thirtysec"); n=no;}
	| ".quarterT" {NoteOps no = new NoteOps("len"); no.addOperand(n); no.addLength("quarterT"); n=no;}
	| ".eighthT" {NoteOps no = new NoteOps("len"); no.addOperand(n); no.addLength("eighthT"); n=no;}
	| ".sixteenthT" {NoteOps no = new NoteOps("len"); no.addOperand(n); no.addLength("sixteenthT"); n=no;}
	| ".thirtysecT" {NoteOps no = new NoteOps("len"); no.addOperand(n); no.addLength("thirtysecT"); n=no;}

	)* { return n; })
}

Expression lenClass(Expression n) throws Exception: {
	Token len;
	System.out.println("lenClass");
} {
	len = <LENGTH> {
		NoteOps no = new NoteOps("len");
		no.addOperand(n);
		no.addLength(len.image);
		return no;
	}
}

Expression pitch(Expression n) throws Exception: {
	Token mod;
	Expression e;
	System.out.println("pitch of the note");
} {
	mod = <DEGREE> {
		NoteOps no = new NoteOps("pit");
		no.addOperand(n);
		no.addPitch(mod.image);
		return no;
	}
	| (mod = "+" | mod = "-") e = arithExpr() {
		NoteOps no = new NoteOps("pit");
		no.addOperand(n);
		no.addNum(e);
		no.addMod(mod.image);
		return no;
	}
}

Expression length(Expression n) throws Exception: {
	Expression e;
	Token mod = null;
	Token numer;
	System.out.println("called length");
} {
	(mod = "+" | mod = "-") e = arithExpr() {
		NoteOps no = new NoteOps("len");
		no.addOperand(n);
		no.addNum(e);
		no.addMod(mod.image);
		return no;
	}
	| numer = <INT> ("/" mod = <INT>)? {
		NoteOps no = new NoteOps("len");
		no.addOperand(n);
		if (mod != null)
			no.addLength(numer.image + "/" + mod.image);
		else
			no.addLength(numer.image);
		return no;
	}
}

Expression volume(Expression n) throws Exception: {
	Expression e;
	Token mod = null;
} {
	(mod = "+" | mod = "-")? e = arithExpr() {
		NoteOps no = new NoteOps("vol");
		no.addOperand(n);
		no.addNum(e);
		if(mod != null)
			no.addMod(mod.image);
		return no;
	}
}

Expression arithExpr() throws Exception: {
	Expression e1;
	Expression e2 = null;
	Token op = null;
} {
	// <PLUS> contains + and -
	e1 = mulOrDiv() ((op = "+" | op = "-") e2 = arithExpr())? {
		if (op != null) {
			BinaryOperator bo = new BinaryOperator(op.image);
			bo.addOperand(e1);
			bo.addOperand(e2);
			return bo;
		}
		else
			return e1;
	}
}

Expression mulOrDiv() throws Exception: {
	Expression e1;
	Expression e2 = null;
	Token op = null;
} {
	// PORD contains *, %, and /
	e1 = unary() ((op = "*" | op = "%" | op = "/") e2 = arithExpr())? {
		if (op != null) {
			BinaryOperator bo = new BinaryOperator(op.image);
			bo.addOperand(e1);
			bo.addOperand(e2);
			return bo;
		}
		else
			return e1;
	}
}



Expression unary() throws Exception: {
	Expression e = null;
	Expression base = null;
	Token op = null;
	Token post = null;
	Token id = null;
} {
	(op = "-")? ("(" e = arithExpr() ")" | id = <ID> post = <POST> | base = var()) {
		if (e == null) {
			if (base != null) {
				Expression ret = base;
				if (op != null) {
					UnaryOperator uo = new UnaryOperator(op.image);
					uo.addOperand(ret);
					ret = uo;
				}
				return ret;
			}
			else if (id != null) {
				VariableReference ref = new VariableReference(id.image, SymbolTable.currentFunctionScope);
				UnaryOperator uo = new UnaryOperator(post.image);
				uo.addOperand(ref);
				uo.addFunc(SymbolTable.currentFunctionScope);
				uo.addVar(id.image);
				if (op != null) {
					UnaryOperator uo2 = new UnaryOperator(op.image);
					uo2.addOperand(uo);
					uo = uo2;
				}
				return uo;
			}
		}
		else {
			if (op == null)
				return e;
			else {
				UnaryOperator uo = new UnaryOperator(op.image);
				uo.addOperand(e);
				return uo;
			}
		}
	}
}

Expression var() throws Exception: {
	Token t;
	Expression expr;
} {
	t = <INT> { return new ScalrNum(Integer.parseInt(t.image)); }
	| (expr = sequence() | expr = note()) { return expr; }
	| t = <ID> { return new VariableReference(t.image, SymbolTable.currentFunctionScope); }
}
