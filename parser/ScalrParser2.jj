options
{
  LOOKAHEAD=3;

}

PARSER_BEGIN(ScalrParser2)
package parser;
import java.io.*;
import scalr.variable.*;
import scalr.Exceptions.*;
import tuple.*;
import scalr.expression.*;
import java.util.ArrayList;
import java.util.Collections;

public class ScalrParser2 {
    public static void main(String[] args) throws TypeError {
		BufferedReader br = null;
        String text = "";
        try {
			br = new BufferedReader(new FileReader(args[0]));
            String line = "";
            while ((line = br.readLine()) != null) {
                text += line + "\n";

            }
        ScalrParser2 parser = new ScalrParser2(new java.io.StringReader(text));
        SymbolTable.addFunc("test");
        SymbolTable.currentFunctionScope = "test";
        parser.assignment();
        System.out.println(SymbolTable.reference);
	    System.out.println("grats, your program compiled alright");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}
PARSER_END(ScalrParser2)

SKIP : { " " | "\t" | <"/*" (~[])* "*/"> | "\n"}
TOKEN: {
       "and" | "or" | "not" | "->" | "." | /*"\n" |*/
        "," | "\"" | "+" | "-" | "%" | "(" | ")" | "[" | "]" |
	"note" | "pitch" | "volume" | 
       	"duration" | "quarter" | "half" | "whole" |
	"end" | "func" | "main" | "while" | "foreach" |
	 "in" |	"if" | "else" | "import" | "track" | ".fscalr" |
	<POST: "--" | "++"> |
	<LENGTH: "whole" | "half" | "quarter" | "eighth" | "sixteenth" | "thirtysec" | "quarterT" |
		"eighthT" | "sixteenthT" | "thirtysecT"> |
	<ASSIGN: "=" | "+=" | "-=" | "*=" | "/=" | "%="> |
	<RELN: "==" | "<" | ">" | ">=" "<="> |
	<INT: "0" | ["1"-"9"](["0"-"9"])*> |
	<ID: ["a"-"z"](["A"-"Z"] | ["a"-"z"] | <INT> | "_")*> |
    	<DEGREE: ["A"-"G"]("b" | "s")?(["0"-"9"] | "1""0")>
	}
	





// *** FUNCTIONS ARE A MASSIVE PROBLEM ***
// on return assign the name of the function to the expressions underneath it



void idDefs(ArrayList<String> params): {
	Token t;
} {
	t = <ID> { params.add(t.image); }
}
void function() throws Exception: {
	System.out.println("starting function def");
	String funcName;
	Function f;
	ArrayList<String> params= new ArrayList<String>();
	ArrayList<Expression> expressions = new ArrayList<Expression>();
	Expression returnSeq;
} {
"func" funcName=id() {SymbolTable.currentFunctionScope= funcName; f= new Function(funcName); } 
	"(" (idDefs(params) ("," idDefs(params))*)? {
		for(String s: params){
			f.addParameter(s);
		}
	} 

	")" expressions = line1() {
		for(Expression e: expressions){
			f.addStatement(e);
		}
	}
	
	returnSeq= sequence(){
		System.out.println("hit return sequence");
		f.addStatement(returnSeq);
	} 
	"end" {
		System.out.println("adding function with name "+ f.getName());
		SymbolTable.addFuncRef(f);
	}
}

String track(): {String out;
				Expression e;}
{
	"track" "->" e=sequence() 
	{
		Sequence temp = (Sequence) e.getValue();
		out = temp.toString();
		return out;
	}
}

Expression line() throws Exception: {
	Expression e;
} {
//loop() {System.out.println("loop line matched");}
//| conditional() {System.out.println("conditional line matched");}
//| 
	assignment() {
		return null;
	}
	|
	note() {

	}
	|
	track() {

	}

}




ArrayList<Expression> line1() throws Exception: {
	ArrayList<Expression> out; 
	Expression e;
} {
e=line() out=line1(){
	if(e != null){
	out.add(e);
	return out;
	}
	return out;
}
| {}{
	return new ArrayList<Expression>();
}
}

void assignment() throws Exception: {
	String t1;
	Expression t2;
} 
{
	
	t1=id() <ASSIGN> t2=note() { CreationOperator co = new CreationOperator(t1);
									co.addOperand(t2);
									co.addFunc(SymbolTable.currentFunctionScope);
								}
	|
	t1=id() <ASSIGN> t2=sequence() {CreationOperator co = new CreationOperator(t1);
									co.addOperand(t2);
									co.addFunc(SymbolTable.currentFunctionScope);}
	|

	t1=id() <ASSIGN> t2=expression(){
									CreationOperator co = new CreationOperator(t1);
									co.addOperand(t2);
									co.addFunc(SymbolTable.currentFunctionScope);
	}
}
String id() throws Exception:
{Token t;}
{
t=<ID> {return t.image;}  //blah should be changed with the string that shows in which function we ARE!!!
}

Expression expression() throws Exception: {
	Expression ex;
	Pair<String, Expression> t;
} 
{
ex=expr1() t=expr0()
{
	BinaryOperator out = new BinaryOperator(t.getValue0());
	out.addOperand(ex);
	out.addOperand(t.getValue1());
	return out;
}
|
ex= expr1()
{
	return ex;
}
}


Pair<String, Expression> expr0() throws Exception: {Expression e;} {
"+" e=expr1() { return Pair.with("+", e); }
| "-" e=expr1() { return Pair.with("-", e); }
}

Expression expr1() throws Exception: {
	Expression ex;
	Pair<String, Expression> t;
} { ex=expr3() t=expr2() 
{
	BinaryOperator out = new BinaryOperator(t.getValue0());
	out.addOperand(ex);
	out.addOperand(t.getValue1());
	return out;
}
|
ex= expr3()
{
	return ex;
}
}

Pair<String, Expression> expr2() throws Exception: {Expression e;} {
"*" e=expr3() { return Pair.with("*", e); }
| "/" e=expr3() { return Pair.with("/", e); }
}

Expression expr3() throws Exception: {
	Expression ex;
	Pair<String, Expression> t;
} {ex = expr5() t=expr4()
{
	BinaryOperator out = new BinaryOperator(t.getValue0());
	out.addOperand(ex);
	out.addOperand(t.getValue1());
	return out;
}
|
ex= expr5()
{
	return ex;
}
}

Pair<String, Expression> expr4() throws Exception: {
	Expression ex;
} {
	"%" ex = expr5() { return Pair.with("%", ex); }
}

Expression expr5() throws Exception: {
	Expression ex;
} {
"(" ex = expression() ")" {return ex;}
| ex = operand() {return ex;}
}

ScalrNum num() throws Exception:
{Token t;}
{
t=<INT> {return new ScalrNum(Integer.parseInt(t.image));}
}

Expression operand() throws Exception: {
	Expression ex;
	String t;
	Sequence s;
} {
s = funcall() {return s;}
| 
t=id() {return SymbolTable.getMember(SymbolTable.currentFunctionScope, t);}
| ex = note() 
{
	return ex;
}
| ex = sequence() {return ex;}
| ex=num() {return ex;}
}

Sequence funcall() throws Exception: {
	Sequence s;
	String t;
	ArrayList<Expression> ex;
	System.out.println("called funcall");
} { 
t = id() "(" ex = parameters() ")" 
{
	
	Function f = SymbolTable.getFuncRef(t);
	if(ex.isEmpty()){
		s = (Sequence) f.getValue();

	}
	else{
		Collections.reverse(ex);
		Expression[] temp = ex.toArray(new Expression[ex.size()]);
		s = (Sequence) f.getValue(temp);	
	}
	
	return s;
}
|
t = id()  
{
	Function f = SymbolTable.getFuncRef(t);
	s = (Sequence) f.getValue();
	return s;
}
}

ArrayList<Expression> parameters() throws Exception: {
	Expression ex;
	ArrayList<Expression> ex2;
} { 
ex = operand() ex2 = parameters1() 
{
	ex2.add(ex);
}
|
ex= operand()
{
	ex2 = new ArrayList<Expression>();
	ex2.add(ex);
	return ex2;
}

}

ArrayList<Expression> parameters1() throws Exception: {
	ArrayList<Expression> out;
} { "," out = parameters() {return out;}}

Expression sequence() throws Exception: {
	Sequence s;
	Expression n;
	String id;

} {
"[" "]"
{
	System.out.println("sequence case 1");
	s = new Sequence();
	return s;
}
| "[" n = note() s = sequence1() "]" 
{
	System.out.println("sequence case 2");
	s.addNoteToStart(n);
	return s;
}
| id = id() 
{
	System.out.println("sequence case 3");
	Expression e = SymbolTable.getMember(SymbolTable.currentFunctionScope, id);
	return e;
}
}

Sequence sequence1() throws Exception: {
	Sequence s;
	Expression n;

} {
"," n = note() s = sequence1()
{
	s.addNoteToStart(n);
	return s;
}
| {}
{
	s = new Sequence();
	return s;
}
}

Expression note(): {
	Token t;
	Expression n = Note.note();
} {
	("note" | t = <ID> { n = new VariableReference(t.image, SymbolTable.currentFunctionScope); }) 
	(".pitch(" n = pitch(n) ")" | ".length(" n = length(n) ")" | ".volume(" n = volume(n) ")" | "." n = lenClass(n))* { return n; }
}

Expression lenClass(Expression n): {
	Token len;
} {
	len = <LENGTH> {
		NoteOps no = new NoteOps("len");
		no.addOperand(n);
		no.addLength(len.image);
		return no;
	}
}

Expression pitch(Expression n): {
	Token mod;
	Expression e;
} {
	mod = <DEGREE> {
		NoteOps no = new NoteOps("pit");
		no.addOperand(n);
		no.addPitch(mod.image);
		return no;
	}
	| (mod = "+" | mod = "-") e = arithExpr() {
		NoteOps no = new NoteOps("pit");
		no.addOperand(n);
		no.addNum(e);
		no.addMod(mod.image);
		return no;
	}
}

Expression length(Expression n): {
	Expression e;
	Token mod = null;
	Token numer;
} {
	(mod = "+" | mod = "-") e = arithExpr() {
		NoteOps no = new NoteOps("len");
		no.addOperand(n);
		no.addNum(e);
		no.addMod(mod.image);
		return no;
	}
	| numer = <INT> ("/" mod = <INT>)? {
		NoteOps no = new NoteOps("len");
		no.addOperand(n);
		if (mod != null)
			no.addLength(numer.image + "/" + mod.image);
		else
			no.addLength(numer.image);
		return no;
	}
}

Expression volume(Expression n): {
	Expression e;
	Token mod = null;
} {
	(mod = "+" | mod = "-")? e = arithExpr() {
		NoteOps no = new NoteOps("vol");
		no.addOperand(n);
		no.addNum(e);
		if(mod != null)
			no.addMod(mod.image);
		return no;
	}
}

Expression arithExpr(): {
	Expression e1;
	Expression e2 = null;
	Token op = null;
} {
	// <PLUS> contains + and -
	e1 = mulOrDiv() ((op = "+" | op = "-") e2 = arithExpr())? {
		if (op != null) {
			BinaryOperator bo = new BinaryOperator(op.image);
			bo.addOperand(e1);
			bo.addOperand(e2);
			return bo;
		}
		else
			return e1;
	}
}

Expression mulOrDiv(): {
	Expression e1;
	Expression e2 = null;
	Token op = null;
} {
	// PORD contains *, %, and /
	e1 = unary() ((op = "*" | op = "%" | op = "/") e2 = arithExpr())? {
		if (op != null) {
			BinaryOperator bo = new BinaryOperator(op.image);
			bo.addOperand(e1);
			bo.addOperand(e2);
			return bo;
		}
		else
			return e1;
	}
}



Expression unary(): {
	Expression e = null;
	Expression base = null;
	Token op = null;
	Token post = null;
	Token id = null;
} {
	(op = "-")? ("(" e = arithExpr() ")" | id = <ID> post = <POST> | base = var()) {
		if (e == null) {
			if (base != null) {
				Expression ret = base;
				if (op != null) {
					UnaryOperator uo = new UnaryOperator(op.image);
					uo.addOperand(ret);
					ret = uo;
				}
				return ret;
			}
			else if (id != null) {
				VariableReference ref = new VariableReference(id.image, SymbolTable.currentFunctionScope);
				UnaryOperator uo = new UnaryOperator(post.image);
				uo.addOperand(ref);
				uo.addFunc(SymbolTable.currentFunctionScope);
				uo.addVar(id.image);
				if (op != null) {
					UnaryOperator uo2 = new UnaryOperator(op.image);
					uo2.addOperand(uo);
					uo = uo2;
				}
				return uo;
			}
		}
		else {
			if (op == null)
				return e;
			else {
				UnaryOperator uo = new UnaryOperator(op.image);
				uo.addOperand(e);
				return uo;
			}
		}
	}
}

Expression var(): {
	Token t;
	Expression expr;
} {
	t = <INT> { return new ScalrNum(Integer.parseInt(t.image)); }
	| (expr = sequence() | expr = note()) { return expr; }
	| t = <ID> { return new VariableReference(t.image, SymbolTable.currentFunctionScope); }
}











