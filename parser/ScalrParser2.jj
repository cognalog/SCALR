options
{
  LOOKAHEAD=3;
}

PARSER_BEGIN(ScalrParser2)
package parser;
import java.io.*;
import scalr.variable.*;
import scalr.Exceptions.*;
import tuple.*;
import scalr.expression.*;
import java.util.ArrayList;
import java.util.Collections;

public class ScalrParser2 {
    public static void main(String[] args) throws TypeError {
		BufferedReader br = null;
        String text = "";
        try {
			br = new BufferedReader(new FileReader(args[0]));
            String line = "";
            while ((line = br.readLine()) != null) {
                text += line + "\n";

            }
        ScalrParser2 parser = new ScalrParser2(new java.io.StringReader(text));
        parser.assignment();
        System.out.println(SymbolTable.reference);
	    System.out.println("grats, your program compiled alright");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}
PARSER_END(ScalrParser2)

SKIP : { " " | "\t" | <"/*" (~[])* "*/"> | "\n"}
TOKEN: {
       "and" | "or" | "not" | "->" | "." | /*"\n" |*/
        "," | "\"" | "+" | "-" | "%" | "(" | ")" | "[" | "]" |
	"note" | "pitch" | "volume" | 
       	"duration" | "quarter" | "half" | "whole" |
	"end" | "func" | "main" | "while" | "foreach" |
	 "in" |	"if" | "else" | "import" | "track" | ".fscalr" |
	<ASSIGN: "=" | "+=" | "-=" | "*=" | "/=" | "%="> |
	<RELN: "==" | "<" | ">" | ">=" "<="> |
	<INT: "0" | ["1"-"9"](["0"-"9"])*> |
	<ID: ["a"-"z"](["A"-"Z"] | ["a"-"z"] | <INT> | "_")*> |
    	<DEGREE: ["A"-"G"]("b" | "s")?(["0"-"9"] | "1""0")>
	}
	
void assignment(): {
	String t1;
	Expression t2;
} {
	t1=id() <ASSIGN> t2=expression(){
		try {
			SymbolTable.addFunc("blah");
			//ScalrNum n = new ScalrNum(Integer.parseInt(t2.image));
			SymbolTable.addReference("blah", t1, t2);
			ScalrNum temp = (ScalrNum) SymbolTable.getMember("blah", t1);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
String id():
{Token t;}
{
t=<ID> {return t.image;}  //blah should be changed with the string that shows in which function we ARE!!!
}

Expression expression(): {
	Expression ex;
	Pair<String, Expression> t;
} 
{
ex=expr1() t=expr0()
{
	BinaryOperator out = new BinaryOperator(t.getValue0());
	out.addOperand(ex);
	out.addOperand(t.getValue1());
	return out;
}
|
ex= expr1()
{
	return ex;
}
}


Pair<String, Expression> expr0(): {Expression e;} {
"+" e=expr1() { return Pair.with("+", e); }
| "-" e=expr1() { return Pair.with("-", e); }
}

Expression expr1(): {
	Expression ex;
	Pair<String, Expression> t;
} { ex=expr3() t=expr2() 
{
	BinaryOperator out = new BinaryOperator(t.getValue0());
	out.addOperand(ex);
	out.addOperand(t.getValue1());
	return out;
}
|
ex= expr3()
{
	return ex;
}
}

Pair<String, Expression> expr2(): {Expression e;} {
"*" e=expr3() { return Pair.with("*", e); }
| "/" e=expr3() { return Pair.with("/", e); }
}

Expression expr3(): {
	Expression ex;
	Pair<String, Expression> t;
} {ex = expr5() t=expr4()
{
	BinaryOperator out = new BinaryOperator(t.getValue0());
	out.addOperand(ex);
	out.addOperand(t.getValue1());
	return out;
}
|
ex= expr5()
{
	return ex;
}
}

Pair<String, Expression> expr4(): {
	Expression ex;
} {
	"%" ex = expr5() { return Pair.with("%", ex); }
}

Expression expr5(): {
	Expression ex;
} {
"(" ex = expression() ")" {return ex;}
| ex = operand() {return ex;}
}

ScalrNum num():
{Token t;}
{
t=<INT> {return new ScalrNum(Integer.parseInt(t.image));}
}

Expression operand(): {
	Expression ex;
	String t;
	Sequence s;
} {
s = funcall() {return s;}
| 
t=id() {return SymbolTable.getMember("blah", t);}
//| note() {System.out.println("operand is note");}
//| sequence() {System.out.println("operand is sequence");}
| 
ex=num() {return ex;}
}

Sequence funcall(): {
	Sequence s;
	String t;
	ArrayList<Expression> ex;
} { 
t = id() "(" ex = parameters() ")" 
{
	Collections.reverse(ex);
	Function f = SymbolTable.getFuncRef(t);
	s = f.getValue(ex.toArray(new Expression[f.getSize()]));
	return s;
}
|
t = id() 
{
	Function f = SymbolTable.getFuncRef(t);
	s = f.getValue();
	return s;
}
}

ArrayList<Expression> parameters(): {
	Expression ex;
	ArrayList<Expression> ex2;
} { 
ex = operand() ex2 = parameters1() 
{
	ex2.add(ex);
}
|
ex= operand()
{
	ex2 = new ArrayList<Expression>();
	ex2.add(ex);
	return ex2;
}
}

ArrayList<Expression> parameters1(): {
	ArrayList<Expression> out;
} { "," out = parameters() {return out;}}