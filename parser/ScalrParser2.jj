options
{
  LOOKAHEAD=3;

}

PARSER_BEGIN(ScalrParser2)
package parser;
import java.io.*;
import scalr.variable.*;
import scalr.Exceptions.*;
import tuple.*;
import scalr.expression.*;
import java.util.ArrayList;
import java.util.Collections;

public class ScalrParser2 {
    public static void main(String[] args) throws TypeError {
		BufferedReader br = null;
        String text = "";
        try {
			br = new BufferedReader(new FileReader(args[0]));
            String line = "";
            while ((line = br.readLine()) != null) {
                text += line + "\n";

            }
        ScalrParser2 parser = new ScalrParser2(new java.io.StringReader(text));
        SymbolTable.addFunc("test");
        SymbolTable.currentFunctionScope = "test";
        parser.assignment();
        parser.assignment();
        parser.assignment();
        System.out.println(SymbolTable.reference);
	    System.out.println("grats, your program compiled alright");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}
PARSER_END(ScalrParser2)

SKIP : { " " | "\t" | <"/*" (~[])* "*/"> | "\n"}
TOKEN: {
       "and" | "or" | "not" | "->" | "." | /*"\n" |*/
        "," | "\"" | "+" | "-" | "%" | "(" | ")" | "[" | "]" |
	"note" | "pitch" | "volume" | 
       	"duration" | "quarter" | "half" | "whole" |
	"end" | "func" | "main" | "while" | "foreach" |
	 "in" |	"if" | "else" | "import" | "track" | ".fscalr" |
	<ASSIGN: "=" | "+=" | "-=" | "*=" | "/=" | "%="> |
	<RELN: "==" | "<" | ">" | ">=" "<="> |
	<INT: "0" | ["1"-"9"](["0"-"9"])*> |
	<ID: ["a"-"z"](["A"-"Z"] | ["a"-"z"] | <INT> | "_")*> |
    	<DEGREE: ["A"-"G"]("b" | "s")?(["0"-"9"] | "1""0")>
	}
	





// *** FUNCTIONS ARE A MASSIVE PROBLEM ***
// on return assign the name of the function to the expressions underneath it



void idDefs(ArrayList<String> params): {
	Token t;
} {
	t = <ID> { params.add(t.image); }
}
void function() throws Exception: {
	System.out.println("starting function def");
	String funcName;
	Function f;
	ArrayList<String> params= new ArrayList<String>();
	ArrayList<Expression> expressions = new ArrayList<Expression>();
	Expression returnSeq;
} {
"func" funcName=id() {SymbolTable.currentFunctionScope= funcName; f= new Function(funcName); } 
	"(" (idDefs(params) ("," idDefs(params))*)? {
		for(String s: params){
			f.addParameter(s);
		}
	} 

	")" expressions = line1() {
		for(Expression e: expressions){
			f.addStatement(e);
		}
	}
	
	returnSeq= sequence(){
		System.out.println("hit return sequence");
		f.addStatement(returnSeq);
	} 
	"end" {
		System.out.println("adding function with name "+ f.getName());
		SymbolTable.addFuncRef(f);
	}
}
Expression line() throws Exception: {
	System.out.println("LINE");
	Expression e;
} {
//loop() {System.out.println("loop line matched");}
//| conditional() {System.out.println("conditional line matched");}
//| 
	assignment() {
		return null;
	}

}


ArrayList<Expression> line1() throws Exception: {
	ArrayList<Expression> out; 
	Expression e;
} {
e=line() out=line1(){
	if(e != null){
	out.add(e);
	return out;
	}
	return out;
}
| {}{
	return new ArrayList<Expression>();
}
}

void assignment() throws Exception: {
	System.out.println("called assignment");
	String t1;
	Expression t2;
} 
{
	
	t1=id() <ASSIGN> t2=note() { SymbolTable.addReference(SymbolTable.currentFunctionScope, t1, t2);}
	|
	t1=id() <ASSIGN> t2=sequence() {SymbolTable.addReference(SymbolTable.currentFunctionScope, t1, t2);}
	|

	t1=id() <ASSIGN> t2=expression(){
		try {
			
			//ScalrNum n = new ScalrNum(Integer.parseInt(t2.image));
			SymbolTable.addReference(SymbolTable.currentFunctionScope, t1, t2);
			//ScalrNum temp = (ScalrNum) SymbolTable.getMember(SymbolTable.currentFunctionScope, t1);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
String id() throws Exception:
{Token t;}
{
t=<ID> {return t.image;}  //blah should be changed with the string that shows in which function we ARE!!!
}

Expression expression() throws Exception: {
	Expression ex;
	Pair<String, Expression> t;
} 
{
ex=expr1() t=expr0()
{
	BinaryOperator out = new BinaryOperator(t.getValue0());
	out.addOperand(ex);
	out.addOperand(t.getValue1());
	return out;
}
|
ex= expr1()
{
	return ex;
}
}


Pair<String, Expression> expr0() throws Exception: {Expression e;} {
"+" e=expr1() { return Pair.with("+", e); }
| "-" e=expr1() { return Pair.with("-", e); }
}

Expression expr1() throws Exception: {
	Expression ex;
	Pair<String, Expression> t;
} { ex=expr3() t=expr2() 
{
	BinaryOperator out = new BinaryOperator(t.getValue0());
	out.addOperand(ex);
	out.addOperand(t.getValue1());
	return out;
}
|
ex= expr3()
{
	return ex;
}
}

Pair<String, Expression> expr2() throws Exception: {Expression e;} {
"*" e=expr3() { return Pair.with("*", e); }
| "/" e=expr3() { return Pair.with("/", e); }
}

Expression expr3() throws Exception: {
	Expression ex;
	Pair<String, Expression> t;
} {ex = expr5() t=expr4()
{
	BinaryOperator out = new BinaryOperator(t.getValue0());
	out.addOperand(ex);
	out.addOperand(t.getValue1());
	return out;
}
|
ex= expr5()
{
	return ex;
}
}

Pair<String, Expression> expr4() throws Exception: {
	Expression ex;
} {
	"%" ex = expr5() { return Pair.with("%", ex); }
}

Expression expr5() throws Exception: {
	Expression ex;
} {
"(" ex = expression() ")" {return ex;}
| ex = operand() {return ex;}
}

ScalrNum num() throws Exception:
{Token t;}
{
t=<INT> {return new ScalrNum(Integer.parseInt(t.image));}
}

Expression operand() throws Exception: {
	Expression ex;
	String t;
	Sequence s;
} {
s = funcall() {return s;}
| 
t=id() {return SymbolTable.getMember(SymbolTable.currentFunctionScope, t);}
| ex = note() 
{
	return ex;
}
| ex = sequence() {return ex;}
| ex=num() {return ex;}
}

Sequence funcall() throws Exception: {
	Sequence s;
	String t;
	ArrayList<Expression> ex;
	System.out.println("called funcall");
} { 
t = id() "(" ex = parameters() ")" 
{
	System.out.println("funcall case 1");
	Function f = SymbolTable.getFuncRef(t);
	if(ex.isEmpty()){
		s = (Sequence) f.getValue();

	}
	else{
		Collections.reverse(ex);
		Expression[] temp = ex.toArray(new Expression[ex.size()]);
		s = (Sequence) f.getValue(temp);	
	}
	
	return s;
}
|
t = id()  
{
	System.out.println("funcall case 2");
	System.out.println("looking for a function with name "+ t);
	Function f = SymbolTable.getFuncRef(t);
	System.out.println("got the function");	
	s = (Sequence) f.getValue();
	System.out.println("s is " + s);	
	return s;
}
}

ArrayList<Expression> parameters() throws Exception: {
	Expression ex;
	ArrayList<Expression> ex2;
} { 
ex = operand() ex2 = parameters1() 
{
	ex2.add(ex);
}
|
ex= operand()
{
	ex2 = new ArrayList<Expression>();
	ex2.add(ex);
	return ex2;
}

}

ArrayList<Expression> parameters1() throws Exception: {
	ArrayList<Expression> out;
} { "," out = parameters() {return out;}}

Expression sequence() throws Exception: {
	Sequence s;
	Note n;
	String id;

} {
"[" "]"
{
	System.out.println("sequence case 1");
	s = new Sequence();
	return s;
}
| "[" n = note() s = sequence1() "]" 
{
	System.out.println("sequence case 2");
	s.addNoteToStart(n);
	return s;
}
| id = id() 
{
	System.out.println("sequence case 3");
	Expression e = SymbolTable.getMember(SymbolTable.currentFunctionScope, id);
	return e;
}
}

Sequence sequence1() throws Exception: {
	Sequence s;
	Note n;

} {
"," n = note() s = sequence1()
{
	s.addNoteToStart(n);
	return s;
}
| {}
{
	s = new Sequence();
	return s;
}
}

Note note() throws Exception: {
	Note n;
	Sequence s;
	Expression e;
	String t;
	Expression seq;
} {
"note" n = note0() 
{

	return n;
}
| seq = sequence() "[" e=expression() "]" 
{
	s = (Sequence) seq;
	ScalrNum sn= (ScalrNum) e.getValue();
	n= s.getNote(sn.toString());
	return n;
}
| t = id() 
{
	n = (Note) SymbolTable.getMember(SymbolTable.currentFunctionScope, t);
	return n;
}
}

Note note0() throws Exception: {
	String[] sa;
	Note n;
	Note out;
} {
sa = note1() {System.out.println("note1 returned properly");} n = note0()
{
	out = null;
	String s = sa[0];
	if(s.equals("pitch")){
	System.out.println(" before switch to pitch "+ sa[1]);
		out = n.pitch(sa[1]);
		System.out.println("switch to pitch "+ sa[1]);
	}
	if(s.equals("volume")){
		out = n.volume(sa[1]);
	}
	if(s.equals("duration")){
		out = n.length(sa[1]);
	}
	return out;
}
| 
{
	System.out.println("creating new note");
	return Note.note();
}
}

String[] note1() throws Exception: {
	Note n;
	Expression ex;
	Expression ex2;
	String s;
	String[] sa;

} {
"." "pitch" "(" ( s = degree() {} 
	| "+" ex = expr5() {ex2 = ex.getValue();  s = "+" + ex2.toString();}
	| "-" ex = expr5() {ex2 = ex.getValue(); s = "-" + ex2.toString();}
	| n = note() {s = n.pitch.toString();} 
	| ex = expression() {ex2 = ex.getValue(); s = ex2.toString();}) ")"
{
	System.out.println(s);
	sa = new String[2];
	sa[0] = "pitch";
	sa[1] = s;
	return sa;
}
| "." "volume" "(" (
	"+" ex = expr5() {ex2 = ex.getValue(); s = "+" + ex2.toString();}
	| "-" ex = expr5() {ex2 = ex.getValue(); s = "-" + ex2.toString();} 
	| ex = expression() {ex2 = ex.getValue(); s = ex2.toString();}) ")"
{
	sa = new String[2];
	sa[0] = "volume";
	sa[1] = s;
	return sa;
}
| "." "duration" "(" (
	"+" ex = expr5() {ex2 = ex.getValue(); s = "+" + ex2.toString();}
	| "-" ex = expr5() {ex2 = ex.getValue(); s = "-" + ex2.toString();} 
	| ex = expression() {ex2 = ex.getValue(); s = ex2.toString();}) ")"
{
	sa = new String[2];
	sa[0] = "duration";
	sa[1] = s;
	return sa;
}
| "." (s = "quarter".image | s = "half".image | s = "whole".image | s = "eighth".image 
	| s = "sixteenth".image | s = "thirtysec".image | s = "eightT".image | s = "sixteenthT".image 
	| s = "thirtysecT".image)
{
	sa = new String[2];
	sa[0] = "duration";
	sa[1] = s;
	return sa;
}
}

String degree() throws Exception:
{Token t;}
{
t=<DEGREE> {return t.image;}
}
