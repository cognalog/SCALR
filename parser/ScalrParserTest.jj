options
{
  LOOKAHEAD = 3;
//  FORCE_LA_CHECK = true;
}

PARSER_BEGIN(ScalrParserTest)
package parser;
import java.io.*;
import scalr.variable.*;
import scalr.expression.*;
import scalr.Exceptions.*;
import java.util.*;

public class ScalrParserTest {
	public static String currentFunc = "test";
    public static void main(String[] args) throws Exception {
		Scanner in = null;
        String text = "";
        try {
		    in = new Scanner(new File(args[0]));
		    String line = "";
		    while (in.hasNextLine())
		    	text += in.nextLine() + "\n";
                
		    ScalrParserTest parser = new ScalrParserTest(new java.io.StringReader(text));
		    SymbolTable.addFunc(currentFunc);
		    ArrayList<Expression> function = new ArrayList<Expression>();
		    function.add(parser.statement());
		    function.add(parser.statement());
			for(Expression e : function) {
				System.out.println("Type: " + e.getType() + " | Value: " + e.getValue());
			}
			System.out.println("grats, your program compiled alright");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: ");
            e.printStackTrace();
        }
    }
}
PARSER_END(ScalrParserTest)

SKIP : { " " | "\t" | <"/*" (~[])* "*/"> }
TOKEN: {
	"not" | "volume" | "duration" | "end" | "func" | "main" | "while" | "foreach" |
	"import" | "track" | "in" |	"if" | "else" | "note" | "pitch" | 
	"->" | "." | "," | "\"" | "%" | "(" | ")" | "[" | "]" |
    <CREATE: "="> |
    <ASSIGN: "+=" | "-=" | "*=" | "/=" | "%="> |
	<NRELN: "<" | ">" | ">=" | "<="> |
	<AND: "and"> |
	<OR: "or"> |
	<URELN: "==" | "!="> |
	<POST: "--" | "++"> |
	<LENGTH: "whole" | "half" | "quarter" | "eighth" | "sixteenth" | "thirtysec" | "quarterT" |
		"eighthT" | "sixteenthT" | "thirtysecT"> |
	<BOOL: "true" | "false"> |
   	<DEGREE: ["A"-"G"]("b" | "s")?(["0"-"9"] | "10")> |
	<INT: (("0")+ | ("0")* ["1"-"9"] (["0"-"9"])*)> |
	<ID: (["a"-"z"] | "_" | ["A" - "Z"]) (["A"-"Z"] | ["a"-"z"] | <INT> | "_")*>
}

Expression statement() throws Exception: {
	Expression expr;
} {
	("\n")* 
	(
		expr = creation() {
			System.out.println("Assignment from function: " + currentFunc);
			return expr;
		}
		| expr = note() {
			return expr;
		} 
		| expr = whileExpr() {
			return expr;
		}
		| expr = ifExpr() {
			return expr;
		}
	)
	"\n"
}

Expression creation(): {
	Token t1;
	Expression expr;	
} {
	t1 = <ID> <CREATE> expr = arithExpr() {
		CreationOperator co = new CreationOperator(t1.image);
		co.addOperand(expr);
		co.addFunc(currentFunc);
		return co;
	}
}

Expression boolExpr(): {
	Expression e1;
	Expression e2 = null;
	Token op = null;
} {
	e1 = andExpr() (op = <OR> e2 = boolExpr())? {
		if (op != null) {
			BooleanOperator bo = new BooleanOperator(op.image);
			bo.addOperand(e1);
			bo.addOperand(e2);
			return bo;
		}
		else
			return e1;
	}
}

Expression andExpr(): {
	Expression e1;
	Expression e2 = null;
	Token op = null;
} {
	e1 = boolEqualExpr() (op = <AND> e2 = boolExpr())? {
		if (op != null) {
			BooleanOperator bo = new BooleanOperator(op.image);
			bo.addOperand(e1);
			bo.addOperand(e2);
			return bo;
		}
		else
			return e1;
	}
}

Expression boolEqualExpr(): {
	Expression e1;
	Expression e2 = null;
	Token op = null;
} {
	e1 = nrelExpr() (op = <URELN> e2 = boolExpr())? {
		if (op != null) {
			BooleanOperator bo = new BooleanOperator(op.image);
			bo.addOperand(e1);
			bo.addOperand(e2);
			return bo;
		}
		else
			return e1;
	}
}

Expression nrelExpr(): {
	Expression e1;
	Expression e2 = null;
	Token op = null;
} {
	e1 = arithExpr() (op = <NRELN> | op = <URELN>) e2 = arithExpr() {
		if (op != null) {
			BooleanOperator bo = new BooleanOperator(op.image);
			bo.addOperand(e1);
			bo.addOperand(e2);
			return bo;
		}
		else
			return e1;
	}
	| op = <BOOL> {
		return new ScalrBoolean(Boolean.parseBoolean(op.image));
	}
	| "(" e1 = boolExpr() ")" {
		return e1;
	}
}

Expression arithExpr(): {
	Expression e1;
	Expression e2 = null;
	Token op = null;
} {
	// <PLUS> contains + and -
	e1 = mulOrDiv() ((op = "+" | op = "-") e2 = arithExpr())? {
		if (op != null) {
			BinaryOperator bo = new BinaryOperator(op.image);
			bo.addOperand(e1);
			bo.addOperand(e2);
			return bo;
		}
		else
			return e1;
	}
}

Expression mulOrDiv(): {
	Expression e1;
	Expression e2 = null;
	Token op = null;
} {
	// PORD contains *, %, and /
	e1 = unary() ((op = "*" | op = "%" | op = "/") e2 = arithExpr())? {
		if (op != null) {
			BinaryOperator bo = new BinaryOperator(op.image);
			bo.addOperand(e1);
			bo.addOperand(e2);
			return bo;
		}
		else
			return e1;
	}
}



Expression unary(): {
	Expression e = null;
	Expression base = null;
	Token op = null;
	Token post = null;
	Token id = null;
} {
	(op = "-")? ("(" e = arithExpr() ")" | id = <ID> post = <POST> | base = var()) {
		if (e == null) {
			if (base != null) {
				Expression ret = base;
				if (op != null) {
					UnaryOperator uo = new UnaryOperator(op.image);
					uo.addOperand(ret);
					ret = uo;
				}
				return ret;
			}
			else if (id != null) {
				VariableReference ref = new VariableReference(id.image, currentFunc);
				UnaryOperator uo = new UnaryOperator(post.image);
				uo.addOperand(ref);
				uo.addFunc(currentFunc);
				uo.addVar(id.image);
				if (op != null) {
					UnaryOperator uo2 = new UnaryOperator(op.image);
					uo2.addOperand(uo);
					uo = uo2;
				}
				return uo;
			}
		}
		else {
			if (op == null)
				return e;
			else {
				UnaryOperator uo = new UnaryOperator(op.image);
				uo.addOperand(e);
				return uo;
			}
		}
	}
}

Expression var(): {
	Token t;
	Expression expr;
} {
	t = <INT> { return new ScalrNum(Integer.parseInt(t.image)); }
	| (expr = sequence() | expr = note()) { return expr; }
	| t = <ID> { return new VariableReference(t.image, currentFunc); }
}

void track(): {}
{
	"track" "->" "[" sequence() "]"
}

Expression note(): {
	Token t;
	Expression n = Note.note();
} {
	("note" | t = <ID> { n = new VariableReference(t.image, currentFunc); }) 
	(".pitch(" n = pitch(n) ")" | ".length(" n = length(n) ")" | ".volume(" n = volume(n) ")" | "." n = lenClass(n))* { return n; }
}

Expression lenClass(Expression n): {
	Token len;
} {
	len = <LENGTH> {
		NoteOps no = new NoteOps("len");
		no.addOperand(n);
		no.addLength(len.image);
		return no;
	}
}

Expression pitch(Expression n): {
	Token mod;
	Expression e;
} {
	mod = <DEGREE> {
		NoteOps no = new NoteOps("pit");
		no.addOperand(n);
		no.addPitch(mod.image);
		return no;
	}
	| (mod = "+" | mod = "-") e = arithExpr() {
		NoteOps no = new NoteOps("pit");
		no.addOperand(n);
		no.addNum(e);
		no.addMod(mod.image);
		return no;
	}
}

Expression length(Expression n): {
	Expression e;
	Token mod = null;
	Token numer;
} {
	(mod = "+" | mod = "-") e = arithExpr() {
		NoteOps no = new NoteOps("len");
		no.addOperand(n);
		no.addNum(e);
		no.addMod(mod.image);
		return no;
	}
	| numer = <INT> ("/" mod = <INT>)? {
		NoteOps no = new NoteOps("len");
		no.addOperand(n);
		if (mod != null)
			no.addLength(numer.image + "/" + mod.image);
		else
			no.addLength(numer.image);
		return no;
	}
}

Expression volume(Expression n): {
	Expression e;
	Token mod = null;
} {
	(mod = "+" | mod = "-")? e = arithExpr() {
		NoteOps no = new NoteOps("vol");
		no.addOperand(n);
		no.addNum(e);
		if(mod != null)
			no.addMod(mod.image);
		return no;
	}
}

Sequence sequence() : {
	Sequence s = new Sequence();
} {
	"[" ((seqNote(s) | seqID(s)) ("," <ID>)*)? "]" { return s; }
}

void seqNote(Sequence s): {
	Expression e;
} {
	e = note() { s.addNoteToEnd(e); }
}

void seqID(Sequence s): {
	Token t;
} {
	t = <ID> {}
}

Expression whileExpr() throws Exception: {
	ArrayList<Expression> expressions = new ArrayList<Expression>();
	Expression ex;
	Expression arith;
	WhileStatement whileObj;
}{
	"while" "(" ex=boolExpr() { whileObj = new WhileStatement(ex); } ")" ("\n")*
	(arith = statement())+ ("\n")* { whileObj.addStatement(arith); } 
	"end" ("\n")* {
		return whileObj;
	}
}
