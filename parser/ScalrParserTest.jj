options
{
  LOOKAHEAD = 3;
//  FORCE_LA_CHECK = true;
}

PARSER_BEGIN(ScalrParserTest)
package parser;
import java.io.*;
import scalr.variable.*;
import scalr.expression.*;
import scalr.Exceptions.*;
import java.util.*;

public class ScalrParserTest {
	public static String currentFunc = "test";
    public static void main(String[] args) throws Exception {
		BufferedReader br = null;
        String text = "";
        try {
			br = new BufferedReader(new FileReader(args[0]));
            String line = "";
            while ((line = br.readLine()) != null) {
                text += line + "\n";

            }
        ScalrParserTest parser = new ScalrParserTest(new java.io.StringReader(text));
        SymbolTable.addFunc(currentFunc);
        ArrayList<Expression> function = new ArrayList<Expression>();
        function.add(parser.statement());
		for(Expression e : function) {
			System.out.println("Type: " + e.getType() + " | Value: " + e.getValue());
		}
	    System.out.println("grats, your program compiled alright");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: ");
            e.printStackTrace();
        }
    }
}
PARSER_END(ScalrParserTest)

SKIP : { " " | "\t" | <"/*" (~[])* "*/"> }
TOKEN: {
	"and" | "or" | "not" | "volume" | "duration" | "end" | "func" | "main" | "while" | "foreach" |
	"import" | "track" | "in" |	"if" | "else" | "note" | "pitch" | 
	"->" | "." | "," | "\"" | "%" | "(" | ")" | "[" | "]" |
    <CREATE: "="> |
    <ASSIGN: "+=" | "-=" | "*=" | "/=" | "%="> |
	<RELN: "==" | "<" | ">" | ">=" "<="> |
	<POST: "--" | "++"> |
	<LENGTH: "whole" | "half" | "quarter" | "eighth" | "sixteenth" | "thirtysec" | "quarterT" |
		"eighthT" | "sixteenthT" | "thirtysecT"> |
   	<DEGREE: ["A"-"G"]("b" | "s")?(["0"-"9"] | "10")> |
	<INT: (("0")+ | ("0")* ["1"-"9"] (["0"-"9"])*)> |
	<ID: (["a"-"z"] | "_" | ["A" - "Z"]) (["A"-"Z"] | ["a"-"z"] | <INT> | "_")*>
}

void id(ArrayList<String> params): {
	Token t;
} {
	t = <ID> { params.add(t.image); }
}

Expression statement(): {
	Expression expr;
} {
	("\n")* expr = creation() "\n" {
		System.out.println("Assignment from function: " + currentFunc);
		return expr;
	}
}

Expression creation(): {
	Token t1;
	Expression expr;	
} {
	t1 = <ID> <CREATE> expr = arithExpr() {
		CreationOperator co = new CreationOperator(t1.image);
		co.addOperand(expr);
		co.addFunc(currentFunc);
		return co;
	}
}

Expression arithExpr(): {
	Expression e1;
	Expression e2 = null;
	Token op = null;
} {
	// <PLUS> contains + and -
	e1 = mulOrDiv() ((op = "+" | op = "-") e2 = arithExpr())? {
		if (op != null) {
			BinaryOperator bo = new BinaryOperator(op.image);
			bo.addOperand(e1);
			bo.addOperand(e2);
			return bo;
		}
		else
			return e1;
	}
}

Expression mulOrDiv(): {
	Expression e1;
	Expression e2 = null;
	Token op = null;
} {
	// PORD contains *, %, and /
	e1 = unary() ((op = "*" | op = "%" | op = "/") e2 = arithExpr())? {
		if (op != null) {
			BinaryOperator bo = new BinaryOperator(op.image);
			bo.addOperand(e1);
			bo.addOperand(e2);
			return bo;
		}
		else
			return e1;
	}
}



Expression unary(): {
	Expression e = null;
	Expression base = null;
	Token op = null;
	Token post = null;
	Token id = null;
} {
	(op = "-")? ("(" e = arithExpr() ")" | id = <ID> post = <POST> | base = var()) {
		if (e == null) {
			if (base != null) {
				Expression ret = base;
				if (op != null) {
					UnaryOperator uo = new UnaryOperator(op.image);
					uo.addOperand(ret);
					ret = uo;
				}
				return ret;
			}
			else if (id != null) {
				VariableReference ref = new VariableReference(id.image, currentFunc);
				UnaryOperator uo = new UnaryOperator(post.image);
				uo.addOperand(ref);
				uo.addFunc(currentFunc);
				uo.addVar(id.image);
				if (op != null) {
					UnaryOperator uo2 = new UnaryOperator(op.image);
					uo2.addOperand(uo);
					uo = uo2;
				}
				return uo;
			}
		}
		else {
			if (op == null)
				return e;
			else {
				UnaryOperator uo = new UnaryOperator(op.image);
				uo.addOperand(e);
				return uo;
			}
		}
	}
}

Expression var(): {
	Token t;
	Expression expr;
} {
	t = <INT> { return new ScalrNum(Integer.parseInt(t.image)); }
	| (expr = sequence() | expr = note()) { return expr; }
	| t = <ID> { return new VariableReference(t.image, currentFunc); }
}

void track(): {}
{
	"track" "->" "[" sequence() "]"
}

Expression note(): {
	Token t;
	Expression n = Note.note();
} {
	("note" | t = <ID> { n = new VariableReference(t.image, currentFunc); }) 
	(".pitch(" n = pitch(n) ")" | ".length(" n = length(n) ")" | ".volume(" n = volume(n) ")" | "." n = lenClass(n))* { return n; }
}

Expression lenClass(Expression n): {
	Token len;
} {
	len = <LENGTH> {
		NoteOps no = new NoteOps("len");
		no.addOperand(n);
		no.addLength(len.image);
		return no;
	}
}

Expression pitch(Expression n): {
	Token mod;
	Expression e;
} {
	mod = <DEGREE> {
		NoteOps no = new NoteOps("pit");
		no.addOperand(n);
		no.addPitch(mod.image);
		return no;
	}
	| (mod = "+" | mod = "-") e = arithExpr() {
		NoteOps no = new NoteOps("pit");
		no.addOperand(n);
		no.addNum(e);
		no.addMod(mod.image);
		return no;
	}
}

Expression length(Expression n): {
	Expression e;
	Token mod = null;
	Token numer;
} {
	(mod = "+" | mod = "-") e = arithExpr() {
		NoteOps no = new NoteOps("len");
		no.addOperand(n);
		no.addNum(e);
		no.addMod(mod.image);
		return no;
	}
	| numer = <INT> ("/" mod = <INT>)? {
		NoteOps no = new NoteOps("len");
		no.addOperand(n);
		if (mod != null)
			no.addLength(numer.image + "/" + mod.image);
		else
			no.addLength(numer.image);
		return no;
	}
}

Expression volume(Expression n): {
	Expression e;
	Token mod = null;
} {
	(mod = "+" | mod = "-")? e = arithExpr() {
		NoteOps no = new NoteOps("vol");
		no.addOperand(n);
		no.addNum(e);
		if(mod != null)
			no.addMod(mod.image);
		return no;
	}
}

Sequence sequence() : {}
{
	"[" (<ID> ("," <ID>)*)? "]" { return new Sequence(); }
}
