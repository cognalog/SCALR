options
{
  LOOKAHEAD = 3;
//  FORCE_LA_CHECK = true;
}

PARSER_BEGIN(ScalrParserTest)
package parser;
import java.io.*;
import scalr.variable.*;
import scalr.expression.*;
import scalr.Exceptions.*;
import java.util.ArrayList;

public class ScalrParserTest {
	public static String currentFunc = "test";
    public static void main(String[] args) throws Exception {
		BufferedReader br = null;
        String text = "";
        try {
			br = new BufferedReader(new FileReader(args[0]));
            String line = "";
            while ((line = br.readLine()) != null) {
                text += line + "\n";

            }
        ScalrParserTest parser = new ScalrParserTest(new java.io.StringReader(text));
        SymbolTable.addFunc(currentFunc);
        parser.statement();
        parser.statement();
        System.out.println(SymbolTable.reference);
	    System.out.println("grats, your program compiled alright");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: ");
            e.printStackTrace();
        }
    }
}
PARSER_END(ScalrParserTest)

SKIP : { " " | "\t" | <"/*" (~[])* "*/"> }
TOKEN: {
	"and" | "or" | "not" | "->" | "." /*"\n" |*/
    | "," | "\"" | "+" | "-" | "%" | "(" | ")" | "[" | "]" | "note" | "pitch"
    | "volume" |
       	"duration" | "quarter" | "half" | "whole" |
	"end" | "func" | "main" | "while" | "foreach" |
	 "in" |	"if" | "else" | "import" | "track" | ".fscalr" |
	<ASSIGN: "+=" | "-=" | "*=" | "/=" | "%="> |
	<RELN: "==" | "<" | ">" | ">=" "<="> |
	<INT: ("0" | ["1"-"9"](["0"-"9"])*)> |
	<ID: ["a"-"z"](["A"-"Z"] | ["a"-"z"] | <INT> | "_")*> |
    	<DEGREE: ["A"-"G"]("b" | "s")?(["0"-"9"] | "10")>
    | <LENGTH: "whole" | "half" | "quarter" | "eighth" | "sixteenth" |
    		"thirtysec" | "quarterT" | "eighthT" | "sixteenthT" | "thirtysecT">
    | <PLUS: "+" | "-">
	}

void id(ArrayList<String> params): {
	Token t;
} {
	t = <ID> { params.add(t.image); }
}

void statement(): {}
{
	("\n")* creation() "\n" { System.out.println("Assignment from function: " + currentFunc); }
}

void creation(): {
	Token t1;
	Expression expr;	
} {
	t1 = <ID> "=" expr = arithExpr() {
		try {
			SymbolTable.addReference(currentFunc, t1.image, expr);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

Expression arithExpr(): {
	Expression e1;
	Expression e2 = null;
	Token op = null;
} {
	// <PLUS> contains + and -
	e1 = mulOrDiv() ((op = "+" | op = "-") e2 = arithExpr())? {
		if (op != null) {
			BinaryOperator bo = new BinaryOperator(op.image);
			bo.addOperand(e1);
			bo.addOperand(e2);
			return bo;
		}
		else
			return e1;
	}
}

Expression mulOrDiv(): {
	Expression e1;
	Expression e2 = null;
	Token op = null;
} {
	// PORD contains *, %, and /
	e1 = unary() ((op = "*" | op = "%" | op = "/") e2 = arithExpr())? {
		if (op != null) {
			BinaryOperator bo = new BinaryOperator(op.image);
			bo.addOperand(e1);
			bo.addOperand(e2);
			return bo;
		}
		else
			return e1;
	}
}

Expression unary(): {
	Expression e = null;
	Expression base = null;
	Token op = null;
	Token post = null;
} {
	(op = "-")? ("(" e = arithExpr() ")" | base = var() (post = "--" | post = "++")?) {
		if (e == null) {
			Expression ret = base;
			if (post != null) {
				UnaryOperator uo = new UnaryOperator(post.image);
				uo.addOperand(ret);
				ret = uo;
			}
			if (op != null) {
				UnaryOperator uo = new UnaryOperator(op.image);
				uo.addOperand(ret);
				ret = uo;
			}
			return ret;
		}
		else {
			if (op == null)
				return e;
			else {
				UnaryOperator uo = new UnaryOperator(op.image);
				uo.addOperand(e);
				return uo;
			}
		}
	}
}

Expression var(): {
	Token t;
	Expression expr;
} {
	t = <INT> { return new ScalrNum(Integer.parseInt(t.image)); }
	| (expr = sequence() | expr = note()) { return expr; }
	| t = <ID> { return new VariableReference(t.image, currentFunc); }
}

void track(): {}
{
	"track" "->" "[" sequence() "]"
}

Expression note(): {
	Note n = Note.note();
} {
	"note" (("." pitch(n)) | ("." length(n)) | ("." volume(n)))* { return n; }
}

void pitch(Note n): {
	Token mod = null;
	Token idName = null;
	Token length = null;
	Token degree = null;
	Token num = null;
	Expression e = null;
} {
	// Pretty much defines anything that can be in pitch. Type checking will have to be done in the backend
	"pitch(" (((mod = <PLUS>)? idName = <ID> (length = ".length(" ")")?) | degree = <DEGREE> | (mod = <PLUS>)? num = <INT> | (mod = <PLUS>)? e = arithExpr())? ")" { System.out.println("here"); }
}

void length(Note n): {
	Token mod = null;
} {
	"length(" (mod = <PLUS>)? ")" { ; }
}

void volume(Note n): {}
{
	"volume(" ")" { ; }
}

Sequence sequence() : {}
{
	"[" (<ID> ("," <ID>)*)? "]" { return new Sequence(); }
}
