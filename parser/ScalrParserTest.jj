options
{
  LOOKAHEAD=3;
}

PARSER_BEGIN(ScalrParserTest)
package parser;
import java.io.*;
import scalr.variable.*;
import scalr.expression.*;
import scalr.Exceptions.*;
import java.util.ArrayList;

public class ScalrParserTest {
	public static String currentFunc;
    public static void main(String[] args) throws TypeError {
		BufferedReader br = null;
        String text = "";
        try {
			br = new BufferedReader(new FileReader(args[0]));
            String line = "";
            while ((line = br.readLine()) != null) {
                text += line + "\n";

            }
        ScalrParserTest parser = new ScalrParserTest(new java.io.StringReader(text));
        parser.tscalr();
        System.out.println(SymbolTable.reference);
	    System.out.println("grats, your program compiled alright");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}
PARSER_END(ScalrParserTest)

SKIP : { " " | "\t" | <"/*" (~[])* "*/"> | "\n"}
TOKEN: {
       "and" | "or" | "not" | "->" | "." | /*"\n" |*/
        "," | "\"" | "+" | "-" | "%" | "(" | ")" | "[" | "]" |
	"note" | "pitch" | "volume" | 
       	"duration" | "quarter" | "half" | "whole" |
	"end" | "func" | "main" | "while" | "foreach" |
	 "in" |	"if" | "else" | "import" | "track" | ".fscalr" |
	<ASSIGN: "=" | "+=" | "-=" | "*=" | "/=" | "%="> |
	<RELN: "==" | "<" | ">" | ">=" "<="> |
	<INT: "0" | ["1"-"9"](["0"-"9"])*> |
	<ID: ["a"-"z"](["A"-"Z"] | ["a"-"z"] | <INT> | "_")*> |
    	<DEGREE: ["A"-"G"]("b" | "s")?(["0"-"9"] | "1""0")>
	}

void tscalr(): {}
{
	(imp())+ (funcDef())* main() <EOF>
}

void main(): {
	currentFunc = "main";
} {
	"main" (statement())+ "end" (track())+
}

void fscalr(): {}
{
	(funcDef())* <EOF>
}

void imp(): {}
{
	"import" <ID>
}

void funcCall(): {
	Token funcName;
	ArrayList<Expression> params = new ArrayList<Expression>();
} {
	funcName = <ID> "(" (paramExpr(params) ("," paramExpr(params))*)? ")" {
		System.out.println("Function call: " + funcName + " | Arguments: " + params);
	}
}

void paramExpr(ArrayList<Expression> params): {
	Token t;
} {
	t = <INT> { params.add(new ScalrNum(Integer.parseInt(t.image))); }
}

// The production to define a function
void funcDef(): {
	Token name;
	ArrayList<String> params = new ArrayList<String>();
} {
	"func" name = <ID> "(" (id(params) ("," id(params))*)? ")" funcBody(name.image) "end" {
		System.out.println("Function name: " + name + " | Paramters: " + params);
	}
}

void funcBody(String funcName): {
	currentFunc = funcName;
} {
	(statement())+
}

void id(ArrayList<String> params): {
	Token t;
} {
	t = <ID> { params.add(t.image); }
}

void statement(): {}
{
	assignment() { System.out.println("Assignment from function: " + currentFunc); }
}

void assignment(): {
	Token t1;
	Token t2;
} {
	t1 = <ID> <ASSIGN> t2 = <INT> {
		try {
			SymbolTable.addFunc(currentFunc);
			ScalrNum n = new ScalrNum(Integer.parseInt(t2.image));
			SymbolTable.addReference(currentFunc, t1.image, n);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

void track(): {}
{
	"track" "->" sequence()
}

void sequence() : {}
{
	"[" (<ID> ("," <ID>)*)? "]"
}
